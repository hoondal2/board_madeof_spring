// 입과시험 준비

1. 컨트롤러 메서드에 static이 붙지 않음에도 호출 가능한 이유
    ->  메인 메서드는 객체 생성 없이 부르기 때문에 static이 항상 붙는다.
        이와 달리 컨트롤러 메서드들은 static이 붙지 않는다.
        그럼에도 호출이 가능한 이유는 어디선가 객체를 생성해주기 때문이다.

        url로 원격 프로그램을 호출하면, 톰캣에서 객체를 생성한다. 그 후에 메서드를 호출한 것이다.
        static으로 컨트롤러 메서드를 만들어도 되지만,
        iv와 cv 모두 사용 가능한 인스턴스 메서드로 만드는 게 유용하다.

2. Reflection api 설명하기
    ->  구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드, 타입, 변수 등)에
        접근할 수 있게 해주는 자바 API다.
        단점으로 성능 오버헤드와 private접근으로 추상화가 깨져 이로 인한 부작용 등이 있다.
        reflection api는 결론적으로 프레임워크나 라이브러리에서 많이 사용된다.
        프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지 예측할 수 없기 때문에
        이를 동적으로 해결해주기 위해 reflection을 사용한다.

        reflection이 가능한 이유는 JVM이 실행될 때 사용자가 작성한 자바 코드가
        컴파일러를 거쳐 바이트 코드로 변환되어 static 영역에 저장되기 때문이다.
        reflction api는 이 정보를 활용한다. 그래서 클래스 이름만 알고 있다면 언제든
        static영역을 뒤져서 정보를 가져올 수 있는 것이다.

        인자값에 대한 정보는 가져올 수 없기 때문에 사용자가 invoke 호출시 직접 적어야 한다.

3. http 응답 메시지
    ->  1xx : informational
        2xx : success
        3xx : Redirect -> 다른 url로 요청
        4xx : 클라이언트 에러
        5xx : 서버 에러

4. GET과 POST
    ->  GET은 서버의 리소스를 가져오기위해 설계됐다. 쿼리스트링을 통해 소용량 데이터를 전달한다.
        URL에 데이터가 노출되어 보안에 취약하다

    ->  POST는 서버에 데이터를 올리기위해 설계됐다. 전송 데이터 크기에 제한이 없으며
        데이터 요청 메시지의  body에 담아 전송해 보안에 유리하다.

5. 단일 책임의 원칙에 따라 프로그래밍시 분리해야 할 것
    ->  1. 관심사의 분리
        2. 변하는 것과 변하지 않는 것의 분리
        3. 공통 코드(중복 코드)의 분리

6. 스프링과 서블릿, 싱글톤
    ->  서블릿 라이프싸이클을 통해 서블릿이 싱글톤 기반임을 알 수 있다. 톰캣을 실행시키고
        계속해서 새로고침하면 최초 실행시 init()이 호출되고 이후 service()가 재실행됨을 알 수 있다.
        destroy()는 톰캣을 재실행하면 호출된다.
        이는 서블릿이 1개의 인스턴스를 계속해서 재활용하고 재실행하면 버리고 다시 생성하는 것인데,
        스프링 역시 서블릿과 마찬가지로 이러한 싱글톤 기반으로 설계되었다.

        서블릿 인스턴스가 한번 생성/초기화(init())되고 나면, 두번째 호출부터는 빨라진다.
        이는 이미 생성된 서블릿 인스턴스를 재사용하기 때문인데, 생성시의 변환과 컴파일 시간이
        줄어들기 때문이다. 이미 객체가 존재하기 때문에 바로 service()가 응답해주는 것이다.
        하지만 소스가 변경되면 또 변환하고 컴파일해야 해서 다시 객체를 생성한다.

        스프링과의 차이는 여기서 발생하는데, 스프링은 기본적으로 일찍, 요청이 오지 않아도 객체를
        만들어놓기 때문에 빠르다.
        이러한 차이로 서블릿을 lazy-init(지연된 초기화), 스프링을 early-init이라 한다.

7. 유효범위 (scope)
    ->  서블릿과 jsp에는 4가지 저장소가 존재한다. 접근 범위와 생존기간에 따라 구분한다.
        1. pageScope
            페이지 안에서만 저장, 사용가능하다.
        2. application
            webApp 전체에서 접근 가능하며 공통 저장소이다.
            모든 페이지에서 접근 가능하기 때문에, 다른 사용자가 로그인했을 때,
            개별적인 아이디를 저장하기에는 좋은 저장소가 아니다.
        3. session
            어플리케이션 저장소의 단점을 해결 가능하다.
            공통이 아닌, 개별 저장소에 해당하며, 사용자 숫자만큼 저장소가 생긴다.
            사용자가 많아지면 데이터 사용이 커지기 때문에 서버 부담이 제일 크다.
            때문에 최소한의 데이터만 저장해야 한다.
        4. request
            요청할 때마다 하나씩 생기며, 서로 독립적이다.
            요청이 처리되는 동안만 사용되는데, 다른 jsp에게 request를 넘겨 줄 경우도 있다.
            이때 request객체에 담아서 넘겨 줄 수 있다.
            가능하면 제일 부담이 적은 request를 사용하는게 좋다.

8. @RequestParam
    ->  요청의 파라미터를 연결한 매개변수에 붙이는 애너테이션이며 생략가능하다.

    ->  기본적으로 required = true이다. true일 때 쿼리스트링 값을 주지 않으면
        클라이언트 에러(400)가 발생한다. name만 입력하면 널스트링이 들어가게 되는데,
        requestParam의 타입이 String일 경우 에러가 발생하지 않지만, int등과 같이 불일치 할 경우
        400에러가 발생한다.

        required = false일 때는 쿼리스트링 값을 주지 않아도, 널스트링이 들어가도 에러가 발생하지 않는다.
        하지만 타입이 불일치할 경우, 쿼리스트링 값을 주지 않으면 500에러가 발생한다.
        이는 쿼리스트링 값을 주지 않을때 null이 발생하기 때문인데, 이때 타입이 int와 같을 경우
        서버에러(500)가 발생하는 것이다.
        널스트링이 들어가면 역시 타입 불일치로 400에러가 발생한다.

9. @ModelAttribute
    ->  적용 대상을 Model의 속성으로 자동 추가해주는 애너테이션이다.
    ->  반환 타입에 적용할 경우, 애너테이션으로 인해 해당 메서드가 자동으로 호출된다.
        알아서 호출되고 작업결과를 알아서 Model에 저장하기 때문에 임의로 호출하고 작업결과를
        Model에 저장하지 않아도 된다.

10. 세션의 생성 과정
    ->  처음 브라우저가 요청하면 무조건 세션 객체가 하나 생성된다.
        이때 세션 객체마다 sessionId를 가지게 되고, 이 저장소를 사용할 수 있도록
        세션 아이디가 담긴 쿠키를 만들어서 응답으로 보낸다. 브라우저는 이 쿠키를 저장한다.
        이후 이루어지는 모든 요청에 JSESSIONID가 붙어서 가는데, 때문에 서버에서는
        이 아이디를 통해 같은 브라우저에서 온 요청인지 아닌지 알 수 있게 되고, 아이디와 일치하는
        세션 객체를 사용할 수 있게 된다.

    -> setAttribute와 getAttribute를 통해 세션에 정보를 저장하고 꺼낼 수 있다.

11. 세션의 종료
    ->  세션의 종료는 수동과 자동 모두 가능하다.
        수동 종료는 invalidate()을 통한 즉시 종료와
        setMaxInactiveInterval()를 통한 예약 종료가 있다.
        자동종료는 web.xml에 기술하여 구현할 수 있다. session-timeout 태그를 통해
        분단위로 종료 시를 정할 수 있다.

12. 세션 속성 true or false
    ->  jsp 내에 page 디렉티브로 session=false를 설정해주면 세션이 없을 때 생성하지 않는다.
        true는 디폴트이다.
        이는 곧 "세션을 시작할까?"에 대한 물음과 답이다.

        예를 들어 home이나 login 페이지 에서는 세션이 필요치 않고, 여기서 false로 설정해주면
        세션 시간을 줄일 수 있게된다.
        session=false라고 해서 기존 세션에 영향이 가는 것은 아니다. 즉 세션이 끊어지는 것은 아니다.
        일단 세선이 시작하면 true false는 상관이 없는 것이다.

13. DispatcherServlet
    ->  HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는
        프론트 컨트롤러
        과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 모두 등록해주어야 했지만,
        dispatcherServlet이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링해주고
        공통 작업을 처리하면서 편리하게 이용할 수 있게 되었다.

14. redirect와 forward
    ->